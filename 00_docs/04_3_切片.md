# 前言
这一章我们一起来学习下切片类型，通过切片，您可以引用集合中连续的元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。

# 内容

## 切片类型

这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回它在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。

让我们来看看如何在不使用切片的情况下编写此函数的签名，以理解切片将解决的问题：
```rust
fn first_word(s: &String) -> ?
```
`first_word` 函数有一个参数 `&String`。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取 部分 字符串的办法。不过，我们可以返回单词结尾的索引。
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

因为需要逐个元素的检查 String 中的值是否为空格，需要用 as_bytes 方法将 String 转化为字节数组：

```rust
let bytes = s.as_bytes();
```
接下来，使用 iter 方法在字节数组上创建一个迭代器：
```rust
 for (i, &item) in bytes.iter().enumerate() {
```

我们将在后续详细讨论迭代器。现在，只需知道 `iter` 方法返回集合中的每一个元素，而 `enumerate` 包装了 `iter` 的结果，将这些元素作为元组的一部分来返回。从 `enumerate` 返回的元组的第一个元素是索引，第二个元素是对集合中元素的引用。这比自己计算索引要方便一些。

由于 `enumerate` 方法返回一个元组，因此我们可以使用模式来解构该元组。我们将在后续进一步讨论有关模式的问题。在 `for` 循环中，我们指定了一个模式，该模式 `i` 表示元组中的索引，`&item` 表示元组中的单个字节。因为我们从 `.iter（）.enumerate（）` 获取了对集合元素的引用，所以我们在模式中使用 `&`。

在 `for` 循环中，我们通过字节的字面量语法来搜索代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 `s.len()` 返回字符串的长度：

```rust
   if item == b' ' {
            return i;
        }
    }

    s.len()
```

我们现在有一种方法可以找出字符串中第一个单词末尾的索引，但是有一个问题。我们单独返回一个 `usize`，但它在 `&String` 的上下文中只是一个有意义的数字。换言之，由于它是独立于 `String` 的值，因此无法保证它将来仍然有效。现在让我们来使用`first_word` 函数。

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word 的值为 5

    s.clear(); // 这清空了字符串，使其等于 ""

    // word 在此处的值仍然是 5，
    // 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！
}
```
这个程序编译时没有任何错误，而且在调用 s.clear() 之后使用 word 也不会出错。因为 word 与 s 状态完全没有联系，所以 word 仍然包含值 5。可以尝试用值 5 来提取变量 s 的第一个单词，不过这是有 bug 的，因为在我们将 5 保存到 word 之后 s 的内容已经改变。

们不得不时刻担心 word 的索引与 s 中的数据不再同步，这很啰嗦且易出错！如果编写这么一个 second_word 函数的话，管理索引这件事将更加容易出问题。它的签名看起来像这样：

```rust
fn second_word(s: &String) -> (usize, usize) {
```
现在，我们正在跟踪起始索引和结束索引，并且我们有更多的值，这些值是从特定状态的数据计算得出的，但与该状态完全无关。我们有三个不相关的变量需要保持同步。

幸运的是，Rust 有一个解决这个问题的方法：字符串切片。

### 字符串切片
字符串切片是对 String 的一部分的引用，它看起来像这样：
```rust
    let s = String::from("hello world");

    let hello = &s[0..5];
    let world = &s[6..11];
```

`你好`不是对整个 `String` 的引用，而是对 `String` 的一部分的引用，在额外的 `[0..5]` 位中指定。我们通过指定 `[starting_index..ending_index]`，其中 `starting_index` 是切片中的第一个位置，`ending_index` 是切片中的最后一个位置多 1。在内部，切片数据结构存储切片的起始位置和长度，这对应于 `ending_index`减去`starting_index`。因此，在 `let world = &s[6..11];` 的情况下，`world` 将是一个切片，其中包含指向 `s` 索引 6 处的字节的指针，长度值为 `5`。

<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:489px; height:275px;" src="https://www.processon.com/embed/66b2bf2c80d3552cffa4ecaa?cid=66b2bf2c80d3552cffa4ecad"></iframe>

对于 Rust 的 .. range 语法，如果想要从索引 0 开始，可以不写两个点号之前的值。换句话说，如下两个语句是相同的：


### 其他切片

## 总结