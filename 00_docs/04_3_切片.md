# 前言
这一章我们一起来学习下切片类型，通过切片，您可以引用集合中连续的元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。

# 内容

## 切片类型

这里有一个小的编程问题：编写一个函数，该函数接受一个由空格分隔的单词字符串，并返回它在该字符串中找到的第一个单词。如果函数在字符串中找不到空格，则整个字符串必须是一个单词，因此应返回整个字符串。

让我们来看看如何在不使用切片的情况下编写此函数的签名，以理解切片将解决的问题：
```rust
fn first_word(s: &String) -> ?
```
`first_word` 函数有一个参数 `&String`。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取 部分 字符串的办法。不过，我们可以返回单词结尾的索引。
```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

因为需要逐个元素的检查 String 中的值是否为空格，需要用 as_bytes 方法将 String 转化为字节数组：

```rust
let bytes = s.as_bytes();
```
接下来，使用 iter 方法在字节数组上创建一个迭代器：
```rust
 for (i, &item) in bytes.iter().enumerate() {
```

我们将在后续详细讨论迭代器。现在，只需知道 `iter` 方法返回集合中的每一个元素，而 `enumerate` 包装了 `iter` 的结果，将这些元素作为元组的一部分来返回。从 `enumerate` 返回的元组的第一个元素是索引，第二个元素是对集合中元素的引用。这比自己计算索引要方便一些。

由于 `enumerate` 方法返回一个元组，因此我们可以使用模式来解构该元组。我们将在后续进一步讨论有关模式的问题。在 `for` 循环中，我们指定了一个模式，该模式 `i` 表示元组中的索引，`&item` 表示元组中的单个字节。因为我们从 `.iter（）.enumerate（）` 获取了对集合元素的引用，所以我们在模式中使用 `&`。

在 `for` 循环中，我们通过字节的字面量语法来搜索代表空格的字节。如果找到了一个空格，返回它的位置。否则，使用 `s.len()` 返回字符串的长度：

```rust
   if item == b' ' {
            return i;
        }
    }

    s.len()
```

我们现在有一种方法可以找出字符串中第一个单词末尾的索引，但是有一个问题。我们单独返回一个 `usize`，但它在 `&String` 的上下文中只是一个有意义的数字。换言之，由于它是独立于 `String` 的值，因此无法保证它将来仍然有效。现在让我们来使用`first_word` 函数。

```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word 的值为 5

    s.clear(); // 这清空了字符串，使其等于 ""

    // word 在此处的值仍然是 5，
    // 但是没有更多的字符串让我们可以有效地应用数值 5。word 的值现在完全无效！
}
```





### 字符串切片

### 其他切片

## 总结