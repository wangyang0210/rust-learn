# 前言

Rust 有一个非常强大的控制流结构，称为 `match`，它允许你将一个值与一系列模式进行比较，然后根据哪个模式匹配来执行代码。模式可由字面量、变量、通配符和许多其他内容构成；[第 18 章](https://doc.rust-lang.org/book/ch18-00-patterns.html)介绍了所有不同类型的 pattern 及其作用。`match` 的强大之处在于模式的表达性，以及编译器检查，它确保了所有可能的情况都得到处理。



# 内容

可以把 `match` 表达式想象成一台硬币分拣机：硬币滑入有着不同大小孔洞的轨道，每一个硬币都会掉入符合它大小的孔洞。同样，值也会通过 `match` 的每一个模式，并且在遇到第一个 “符合” 的模式时，值会进入相关联的代码块并在执行中被使用。

说到硬币，让我们以 `match` 为例！我们可以编写一个函数，它接受一个未知的美国硬币，并以类似于计数机的方式，确定它是哪个硬币并返回以美分为单位的值。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

拆开 `value_in_cents` 函数中的 `match` 来看。首先，我们列出 `match` 关键字，后跟一个表达式，在这个例子中是 `coin` 的值。这看起来非常像 `if` 使用的表达式，不过这里有一个非常大的区别：对于 `if`，表达式必须返回一个布尔值，而这里它可以是任何类型的。例子中的 `coin` 的类型是我们定义的 `Coin` 枚举。

接下来是 `match` 的分支。一个分支有两个部分：一个模式和一些代码。第一个分支的模式是值 `Coin::Penny` 而之后的 `=>` 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值 `1`。每一个分支之间使用逗号分隔。

当 `match` 表达式执行时，它会按顺序将结果值与每个分支的模式进行比较。如果模式与该值匹配，则执行与该模式关联的代码。如果该模式与值不匹配，则继续执行到下一个分支，就像在硬币分拣机中一样。我们需要多少分支 就有多少：在上方的代码中，我们的 `match` 有 4 个 分支。

与每个分支关联的代码是一个表达式，匹配分支中表达式的结果值是为整个 `match` 表达式返回的值。

如果 match 分支代码很短，我们通常不会使用大括号，就像代码示例中每个分支只返回一个值。如果要在匹配的分支中运行多行代码，则必须使用大括号，并且分支后面的逗号是可选的。例如，以下代码在每次使用 `Coin::Penny`调用该方法时都会打印 “Lucky penny！”，但仍然返回代码块的最后一个值 `1`：

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```



## 绑定值的模式

