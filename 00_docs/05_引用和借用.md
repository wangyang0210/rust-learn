# 前言
在这章我们将开始学习Rust的引用和借用，它们是Rust中重要的概念，它们允许我们创建可变引用，以及创建不可变引用。

# 内容

## 引用和借用

在下面的示例中，我们必须将 String 返回给调用函数，以便在调用 calculate_length 后仍能使用 String，因为 String 被移动到了 calculate_length 内。

下面是如何定义并使用一个（新的）calculate_length 函数，它以一个对象的引用作为参数而不是获取值的所有权：

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

首先，请注意变量声明和函数返回值中的所有元组代码都消失了。注意我们传递 &s1 给 calculate_length，同时在函数定义中，我们获取 &String 而不是 String。
这些 & 符号表示引用，它们允许您引用某个值，而无需获得其所有权。

<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:489px; height:275px;" src="https://www.processon.com/embed/66a2ecf083801d1c4851c52f?cid=66a2ecf083801d1c4851c532"></iframe>

```text
注意：与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，*。
```
让我们仔细看看这里的函数调用：

```rust
let s1 = String::from("hello");

let len = calculate_length(&s1);
```

该 &s1 语法允许我们创建一个指向 s1 的引用 ，但不拥有它。因为它不拥有它，所以当引用停止使用时，它指向的值不会被删除。

同样，函数的签名用 & 来表明参数 s 的类型是引用。让我们添加一些解释性注释：

```rust
fn calculate_length(s: &String) -> usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
```
变量 s 有效的作用域与任何函数参数的作用域相同，但是当停止使用 s 时，引用指向的值不会被删除，因为它没有 s 的所有权。当函数将引用作为参数而不是实际值时，我们不需要返回值来归还所有权，因为我们从未拥有所有权。

我们将创建一个引用的行为称为 借用（**borrowing**）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。

如果我们尝试修改借来的变量，会发生什么呢？

```rust
fn main() {
    let s = String::from("hello");
    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```
现在我们来运行一下，这时候我们会得到一个错误：
```shell
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
  --> src/main.rs:19:5
   |
19 |     some_string.push_str(", world");
   |     ^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference
   |
18 | fn change(some_string: &mut String) {
   |                         +++
```

正如变量默认情况下是不可变的一样，引用也是不可变的。不允许修改我们引用的内容。

## 可变引用

们只需进行一些小的调整来修改借来的值，这些调整使用可变引用：
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
