# 前言
在这章我们将开始学习Rust的引用和借用，它们是Rust中重要的概念，它们允许我们创建可变引用，以及创建不可变引用。

# 内容

## 引用和借用

在下面的示例中，我们必须将 String 返回给调用函数，以便在调用 calculate_length 后仍能使用 String，因为 String 被移动到了 calculate_length 内。

下面是如何定义并使用一个（新的）calculate_length 函数，它以一个对象的引用作为参数而不是获取值的所有权：

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

首先，请注意变量声明和函数返回值中的所有元组代码都消失了。注意我们传递 &s1 给 calculate_length，同时在函数定义中，我们获取 &String 而不是 String。
这些 & 符号表示引用，它们允许您引用某个值，而无需获得其所有权。

<iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:489px; height:275px;" src="https://www.processon.com/embed/66a2ecf083801d1c4851c52f?cid=66a2ecf083801d1c4851c532"></iframe>

```text
注意：与使用 & 引用相反的操作是 解引用（dereferencing），它使用解引用运算符，*。
```
让我们仔细看看这里的函数调用：

```rust
let s1 = String::from("hello");

let len = calculate_length(&s1);
```

该 &s1 语法允许我们创建一个指向 s1 的引用 ，但不拥有它。因为它不拥有它，所以当引用停止使用时，它指向的值不会被删除。

同样，函数的签名用 & 来表明参数 s 的类型是引用。让我们添加一些解释性注释：

```rust
fn calculate_length(s: &String) -> usize { // s 是对 String 的引用
    s.len()
} // 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，
  // 所以什么也不会发生
```

