# 前言

我们将使用泛型来为函数签名、结构体等定义创建一个通用模板，这样它们就可以与多种不同的具体数据类型配合使用。

# 内容

现在让我们正式的开始本章的内容，首先，我们将探索如何利用泛型来定义函数、结构体、枚举和方法。之后，我们将进一步讨论泛型是如何影响代码性能的。



## 在函数中定义

在定义使用泛型的函数时，我们会将泛型参数置于函数签名中，通常用来指定参数和返回值的数据类型。这种做法提升了代码的灵活性，为函数的调用者带来了更广泛的适用性，同时有效避免了代码重复的问题。

继续讨论我们的 `largest` 函数，下面的代码示例展示了两个分别用于找到整数切片和字符切片中最大值的函数。接下来，我们将这两个函数合并为一个使用泛型的单一函数。

```rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {result}");
    assert_eq!(*result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {result}");
    assert_eq!(*result, 'y');
}
```

`largest_i32` 函数用于找出一个 `i32` 类型切片中的最大值。`largest_char` 函数用于在一个 `char` 类型切片中寻找最大值。由于这两个函数的主体代码实际上是相同的，我们将通过引入泛型类型参数，将它们合并为一个单一的泛型函数，以此来消除代码重复。

为了在新的单一函数中参数化类型，我们需要像为函数的值参数命名一样，为类型参数命名。您可以使用任何标识符作为类型参数的名称。但按照惯例，Rust 中的类型参数名称简短，通常只有一个字母，并且遵循 UpperCamelCase（大驼峰命名法）。作为类型的缩写，`T` 成为了大多数 Rust 程序员的首选。因此，我们将使用 `T` 作为类型参数的名称。

```rust
fn largest<T>(list: &[T]) -> &T {
```

我们可以这样理解这个定义：`largest` 函数对某种类型 `T` 是泛型的。这个函数接受一个名为 `list` 的参数，该参数是一个 `T` 类型的值切片。`largest` 函数将返回一个引用，指向相同类型 `T` 的值。

下面的代码呈现了一个泛型版本的 `largest` 函数定义，该定义在其函数签名中使用了泛型数据类型。该代码同样展示了如何调用该函数，无论是传入 `i32` 类型的切片还是 `char` 类型的值。需要注意的是，这段代码目前还无法通过编译，但我们将在本章后续部分对其进行修复。

```rust
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {result}");
}
```

当我们尝试运行的时候，我们将得到以下错误和提示：

```shell
error[E0369]: binary operation `>` cannot be applied to type `&T`
  --> src/main.rs:44:17
   |
44 |         if item > largest {
   |            ---- ^ ------- &T
   |            |
   |            &T
   |
help: consider restricting type parameter `T`
   |
40 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
   |             ++++++++++++++++++++++

```

帮助文本提到了 `std::cmp::PartialOrd`，这是一个 trait（特征），我们将在下一节讨论 traits。目前，您需要知道的是，这个错误表明 `largest` 函数的主体并不适用于 `T` 可能代表的所有类型。因为我们希望在函数体中比较类型 `T` 的值，所以我们只能使用那些值可以被排序的类型。为了启用比较，标准库提供了 `std::cmp::PartialOrd` 特征，您可以在类型上实现这个特征。按照帮助文本的建议，我们将 T 有效的类型限制为仅那些实现了 `PartialOrd` 的类型，这样这个例子就能编译通过了，因为标准库已经在 `i32` 和 `char` 上实现了 `PartialOrd` 特征。

## 在结构中定义

