# 前言

我们将使用泛型来为函数签名、结构体等定义创建一个通用模板，这样它们就可以与多种不同的具体数据类型配合使用。

# 内容

现在让我们正式的开始本章的内容，首先，我们将探索如何利用泛型来定义函数、结构体、枚举和方法。之后，我们将进一步讨论泛型是如何影响代码性能的。



## 在函数中定义

在定义使用泛型的函数时，我们会将泛型参数置于函数签名中，通常用来指定参数和返回值的数据类型。这种做法提升了代码的灵活性，为函数的调用者带来了更广泛的适用性，同时有效避免了代码重复的问题。

继续讨论我们的 `largest` 函数，下面的代码示例展示了两个分别用于找到整数切片和字符切片中最大值的函数。接下来，我们将这两个函数合并为一个使用泛型的单一函数。

```rust
fn largest_i32(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &[char]) -> &char {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {result}");
    assert_eq!(*result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {result}");
    assert_eq!(*result, 'y');
}
```

